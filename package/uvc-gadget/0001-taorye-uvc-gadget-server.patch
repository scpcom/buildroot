From 86138840adee65d48634e99d71ae20ccaa977c87 Mon Sep 17 00:00:00 2001
From: scpcom <scpcom@gmx.de>
Date: Tue, 17 Dec 2024 23:07:16 +0100
Subject: [PATCH] taorye uvc-gadget-server

---
 uvc-gadget.c | 1060 ++++++++++++++------------------------------------
 1 file changed, 301 insertions(+), 759 deletions(-)

diff --git a/uvc-gadget.c b/uvc-gadget.c
index 9dc7516..4614911 100644
--- a/uvc-gadget.c
+++ b/uvc-gadget.c
@@ -17,6 +17,8 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  */
 
+// ./uvc-gadget-server.elf  -u /dev/video0 -d -f1 -i /root/640x360.jpg
+
 #include <sys/ioctl.h>
 #include <sys/mman.h>
 #include <sys/select.h>
@@ -32,12 +34,29 @@
 #include <string.h>
 #include <unistd.h>
 
+#include <glob.h>
+
 #include <linux/usb/ch9.h>
 #include <linux/usb/video.h>
 #include <linux/videodev2.h>
 
 #include "uvc.h"
 
+#define FRAMES_SUPPORT_MAX 8
+
+#define atomic_load(ptr) __atomic_load_n(ptr, __ATOMIC_SEQ_CST)
+#define atomic_store(ptr, value) __atomic_store_n(ptr, value, __ATOMIC_SEQ_CST)
+
+#define SHM_NAME "/uvc_shared_mem_yuyv"
+#define MAX_FRAMEBUFFER_SIZE (1920 * 1080 * 3 / 2) //2048x1080
+#define SHM_SIZE (2 + 2 * MAX_FRAMEBUFFER_SIZE) // 假设 RGB 图像大小为 1920x1080，额外的2字节用于双缓冲同步
+
+typedef struct {
+    uint8_t current_buffer; // Current buffer (0 or 1) for the consumer to read
+    uint8_t consumer_reading; // Consumer is reading (0 or 1)
+    uint8_t buffer[2][MAX_FRAMEBUFFER_SIZE]; // Two buffers for video frames
+} shared_mem_t;
+
 /* Enable debug prints. */
 #undef ENABLE_BUFFER_DEBUG
 #undef ENABLE_USB_REQUEST_DEBUG
@@ -112,19 +131,34 @@ struct uvc_frame_info {
 
 struct uvc_format_info {
     unsigned int fcc;
-    const struct uvc_frame_info *frames;
+    struct uvc_frame_info *frames;
 };
 
-static const struct uvc_frame_info uvc_frames_yuyv[] = {
+static int read_fs_values(const char *path, const char *pattern, unsigned int *val, size_t limit_n) {
+    FILE *fp;
+    size_t cnt;
+
+    if (!(fp = fopen(path, "r"))) {
+        fprintf(stderr, "Failed to read: '%s'\n", path);
+        return -1;
+    }
+
+    for (cnt=0; cnt < limit_n; cnt++) {
+        if(!fscanf(fp, pattern, &val[cnt]))
+            break;
+    }
+
+    fclose(fp);
+    return cnt;
+}
+
+static struct uvc_frame_info uvc_frames_yuyv[FRAMES_SUPPORT_MAX+1];
+/*
+= {
     {
         640,
         360,
-        {666666, 10000000, 50000000, 0},
-    },
-    {
-        1280,
-        720,
-        {50000000, 0},
+        {166666, 333333, 400000, 500000, 666666, 1000000, 2000000, 0},
     },
     {
         0,
@@ -134,17 +168,14 @@ static const struct uvc_frame_info uvc_frames_yuyv[] = {
         },
     },
 };
-
-static const struct uvc_frame_info uvc_frames_mjpeg[] = {
+*/
+static struct uvc_frame_info uvc_frames_mjpeg[FRAMES_SUPPORT_MAX+1];
+/*
+= {
     {
         640,
         360,
-        {666666, 10000000, 50000000, 0},
-    },
-    {
-        1280,
-        720,
-        {50000000, 0},
+        {166666, 333333, 400000, 500000, 666666, 1000000, 2000000, 0},
     },
     {
         0,
@@ -154,36 +185,13 @@ static const struct uvc_frame_info uvc_frames_mjpeg[] = {
         },
     },
 };
+*/
 
-static const struct uvc_format_info uvc_formats[] = {
+static struct uvc_format_info uvc_formats[] = {
     {V4L2_PIX_FMT_YUYV, uvc_frames_yuyv},
     {V4L2_PIX_FMT_MJPEG, uvc_frames_mjpeg},
 };
 
-/* ---------------------------------------------------------------------------
- * V4L2 and UVC device instances
- */
-
-/* Represents a V4L2 based video capture device */
-struct v4l2_device {
-    /* v4l2 device specific */
-    int v4l2_fd;
-    int is_streaming;
-    char *v4l2_devname;
-
-    /* v4l2 buffer specific */
-    enum io_method io;
-    struct buffer *mem;
-    unsigned int nbufs;
-
-    /* v4l2 buffer queue and dequeue counters */
-    unsigned long long int qbuf_count;
-    unsigned long long int dqbuf_count;
-
-    /* uvc device hook */
-    struct uvc_device *udev;
-};
-
 /* Represents a UVC based video output device */
 struct uvc_device {
     /* uvc device specific */
@@ -228,514 +236,13 @@ struct uvc_device {
     unsigned long long int qbuf_count;
     unsigned long long int dqbuf_count;
 
-    /* v4l2 device hook */
-    struct v4l2_device *vdev;
+    int shm_fd;
+    shared_mem_t *shm_ptr;
 };
 
 /* forward declarations */
 static int uvc_video_stream(struct uvc_device *dev, int enable);
 
-/* ---------------------------------------------------------------------------
- * V4L2 streaming related
- */
-
-static int v4l2_uninit_device(struct v4l2_device *dev)
-{
-    unsigned int i;
-    int ret;
-
-    switch (dev->io) {
-    case IO_METHOD_MMAP:
-        for (i = 0; i < dev->nbufs; ++i) {
-            ret = munmap(dev->mem[i].start, dev->mem[i].length);
-            if (ret < 0) {
-                printf("V4L2: munmap failed\n");
-                return ret;
-            }
-        }
-
-        free(dev->mem);
-        break;
-
-    case IO_METHOD_USERPTR:
-    default:
-        break;
-    }
-
-    return 0;
-}
-
-static int v4l2_reqbufs_mmap(struct v4l2_device *dev, int nbufs)
-{
-    struct v4l2_requestbuffers req;
-    unsigned int i = 0;
-    int ret;
-
-    CLEAR(req);
-
-    req.count = nbufs;
-    req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    req.memory = V4L2_MEMORY_MMAP;
-
-    ret = ioctl(dev->v4l2_fd, VIDIOC_REQBUFS, &req);
-    if (ret < 0) {
-        if (ret == -EINVAL)
-            printf("V4L2: does not support memory mapping\n");
-        else
-            printf("V4L2: VIDIOC_REQBUFS error %s (%d).\n", strerror(errno), errno);
-        goto err;
-    }
-
-    if (!req.count)
-        return 0;
-
-    if (req.count < 2) {
-        printf("V4L2: Insufficient buffer memory.\n");
-        ret = -EINVAL;
-        goto err;
-    }
-
-    /* Map the buffers. */
-    dev->mem = calloc(req.count, sizeof dev->mem[0]);
-    if (!dev->mem) {
-        printf("V4L2: Out of memory\n");
-        ret = -ENOMEM;
-        goto err;
-    }
-
-    for (i = 0; i < req.count; ++i) {
-        memset(&dev->mem[i].buf, 0, sizeof(dev->mem[i].buf));
-
-        dev->mem[i].buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        dev->mem[i].buf.memory = V4L2_MEMORY_MMAP;
-        dev->mem[i].buf.index = i;
-
-        ret = ioctl(dev->v4l2_fd, VIDIOC_QUERYBUF, &(dev->mem[i].buf));
-        if (ret < 0) {
-            printf(
-                "V4L2: VIDIOC_QUERYBUF failed for buf %d: "
-                "%s (%d).\n",
-                i, strerror(errno), errno);
-            ret = -EINVAL;
-            goto err_free;
-        }
-
-        dev->mem[i].start =
-            mmap(NULL /* start anywhere */, dev->mem[i].buf.length, PROT_READ | PROT_WRITE /* required */,
-                 MAP_SHARED /* recommended */, dev->v4l2_fd, dev->mem[i].buf.m.offset);
-
-        if (MAP_FAILED == dev->mem[i].start) {
-            printf("V4L2: Unable to map buffer %u: %s (%d).\n", i, strerror(errno), errno);
-            dev->mem[i].length = 0;
-            ret = -EINVAL;
-            goto err_free;
-        }
-
-        dev->mem[i].length = dev->mem[i].buf.length;
-        printf("V4L2: Buffer %u mapped at address %p.\n", i, dev->mem[i].start);
-    }
-
-    dev->nbufs = req.count;
-    printf("V4L2: %u buffers allocated.\n", req.count);
-
-    return 0;
-
-err_free:
-    free(dev->mem);
-err:
-    return ret;
-}
-
-static int v4l2_reqbufs_userptr(struct v4l2_device *dev, int nbufs)
-{
-    struct v4l2_requestbuffers req;
-    int ret;
-
-    CLEAR(req);
-
-    req.count = nbufs;
-    req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    req.memory = V4L2_MEMORY_USERPTR;
-
-    ret = ioctl(dev->v4l2_fd, VIDIOC_REQBUFS, &req);
-    if (ret < 0) {
-        if (ret == -EINVAL)
-            printf("V4L2: does not support user pointer i/o\n");
-        else
-            printf("V4L2: VIDIOC_REQBUFS error %s (%d).\n", strerror(errno), errno);
-        return ret;
-    }
-
-    dev->nbufs = req.count;
-    printf("V4L2: %u buffers allocated.\n", req.count);
-
-    return 0;
-}
-
-static int v4l2_reqbufs(struct v4l2_device *dev, int nbufs)
-{
-    int ret = 0;
-
-    switch (dev->io) {
-    case IO_METHOD_MMAP:
-        ret = v4l2_reqbufs_mmap(dev, nbufs);
-        break;
-
-    case IO_METHOD_USERPTR:
-        ret = v4l2_reqbufs_userptr(dev, nbufs);
-        break;
-
-    default:
-        ret = -EINVAL;
-        break;
-    }
-
-    return ret;
-}
-
-static int v4l2_qbuf_mmap(struct v4l2_device *dev)
-{
-    unsigned int i;
-    int ret;
-
-    for (i = 0; i < dev->nbufs; ++i) {
-        memset(&dev->mem[i].buf, 0, sizeof(dev->mem[i].buf));
-
-        dev->mem[i].buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        dev->mem[i].buf.memory = V4L2_MEMORY_MMAP;
-        dev->mem[i].buf.index = i;
-
-        ret = ioctl(dev->v4l2_fd, VIDIOC_QBUF, &(dev->mem[i].buf));
-        if (ret < 0) {
-            printf("V4L2: VIDIOC_QBUF failed : %s (%d).\n", strerror(errno), errno);
-            return ret;
-        }
-
-        dev->qbuf_count++;
-    }
-
-    return 0;
-}
-
-static int v4l2_qbuf(struct v4l2_device *dev)
-{
-    int ret = 0;
-
-    switch (dev->io) {
-    case IO_METHOD_MMAP:
-        ret = v4l2_qbuf_mmap(dev);
-        break;
-
-    case IO_METHOD_USERPTR:
-        /* Empty. */
-        ret = 0;
-        break;
-
-    default:
-        ret = -EINVAL;
-        break;
-    }
-
-    return ret;
-}
-
-static int v4l2_process_data(struct v4l2_device *dev)
-{
-    int ret;
-    struct v4l2_buffer vbuf;
-    struct v4l2_buffer ubuf;
-
-    /* Return immediately if V4l2 streaming has not yet started. */
-    if (!dev->is_streaming)
-        return 0;
-
-    if (dev->udev->first_buffer_queued)
-        if (dev->dqbuf_count >= dev->qbuf_count)
-            return 0;
-
-    /* Dequeue spent buffer rom V4L2 domain. */
-    CLEAR(vbuf);
-
-    vbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    switch (dev->io) {
-    case IO_METHOD_USERPTR:
-        vbuf.memory = V4L2_MEMORY_USERPTR;
-        break;
-
-    case IO_METHOD_MMAP:
-    default:
-        vbuf.memory = V4L2_MEMORY_MMAP;
-        break;
-    }
-
-    ret = ioctl(dev->v4l2_fd, VIDIOC_DQBUF, &vbuf);
-    if (ret < 0) {
-        return ret;
-    }
-
-    dev->dqbuf_count++;
-
-#ifdef ENABLE_BUFFER_DEBUG
-    printf("Dequeueing buffer at V4L2 side = %d\n", vbuf.index);
-#endif
-
-    /* Queue video buffer to UVC domain. */
-    CLEAR(ubuf);
-
-    ubuf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
-    switch (dev->udev->io) {
-    case IO_METHOD_MMAP:
-        ubuf.memory = V4L2_MEMORY_MMAP;
-        ubuf.length = vbuf.length;
-        ubuf.index = vbuf.index;
-        ubuf.bytesused = vbuf.bytesused;
-        break;
-
-    case IO_METHOD_USERPTR:
-    default:
-        ubuf.memory = V4L2_MEMORY_USERPTR;
-        ubuf.m.userptr = (unsigned long)dev->mem[vbuf.index].start;
-        ubuf.length = dev->mem[vbuf.index].length;
-        ubuf.index = vbuf.index;
-        ubuf.bytesused = vbuf.bytesused;
-        break;
-    }
-
-    ret = ioctl(dev->udev->uvc_fd, VIDIOC_QBUF, &ubuf);
-    if (ret < 0) {
-        /* Check for a USB disconnect/shutdown event. */
-        if (errno == ENODEV) {
-            dev->udev->uvc_shutdown_requested = 1;
-            printf(
-                "UVC: Possible USB shutdown requested from "
-                "Host, seen during VIDIOC_QBUF\n");
-            return 0;
-        } else {
-            return ret;
-        }
-    }
-
-    dev->udev->qbuf_count++;
-
-#ifdef ENABLE_BUFFER_DEBUG
-    printf("Queueing buffer at UVC side = %d\n", ubuf.index);
-#endif
-
-    if (!dev->udev->first_buffer_queued && !dev->udev->run_standalone) {
-        uvc_video_stream(dev->udev, 1);
-        dev->udev->first_buffer_queued = 1;
-        dev->udev->is_streaming = 1;
-    }
-
-    return 0;
-}
-
-/* ---------------------------------------------------------------------------
- * V4L2 generic stuff
- */
-
-static int v4l2_get_format(struct v4l2_device *dev)
-{
-    struct v4l2_format fmt;
-    int ret;
-
-    CLEAR(fmt);
-    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-
-    ret = ioctl(dev->v4l2_fd, VIDIOC_G_FMT, &fmt);
-    if (ret < 0) {
-        return ret;
-    }
-
-    printf("V4L2: Getting current format: %c%c%c%c %ux%u\n", pixfmtstr(fmt.fmt.pix.pixelformat), fmt.fmt.pix.width,
-           fmt.fmt.pix.height);
-
-    return 0;
-}
-
-static int v4l2_set_format(struct v4l2_device *dev, struct v4l2_format *fmt)
-{
-    int ret;
-
-    ret = ioctl(dev->v4l2_fd, VIDIOC_S_FMT, fmt);
-    if (ret < 0) {
-        printf("V4L2: Unable to set format %s (%d).\n", strerror(errno), errno);
-        return ret;
-    }
-
-    printf("V4L2: Setting format to: %c%c%c%c %ux%u\n", pixfmtstr(fmt->fmt.pix.pixelformat), fmt->fmt.pix.width,
-           fmt->fmt.pix.height);
-
-    return 0;
-}
-
-static int v4l2_set_ctrl(struct v4l2_device *dev, int new_val, int ctrl)
-{
-    struct v4l2_queryctrl queryctrl;
-    struct v4l2_control control;
-    int ret;
-
-    CLEAR(queryctrl);
-
-    switch (ctrl) {
-    case V4L2_CID_BRIGHTNESS:
-        queryctrl.id = V4L2_CID_BRIGHTNESS;
-        ret = ioctl(dev->v4l2_fd, VIDIOC_QUERYCTRL, &queryctrl);
-        if (-1 == ret) {
-            if (errno != EINVAL)
-                printf(
-                    "V4L2: VIDIOC_QUERYCTRL"
-                    " failed: %s (%d).\n",
-                    strerror(errno), errno);
-            else
-                printf(
-                    "V4L2_CID_BRIGHTNESS is not"
-                    " supported: %s (%d).\n",
-                    strerror(errno), errno);
-
-            return ret;
-        } else if (queryctrl.flags & V4L2_CTRL_FLAG_DISABLED) {
-            printf("V4L2_CID_BRIGHTNESS is not supported.\n");
-            ret = -EINVAL;
-            return ret;
-        } else {
-            CLEAR(control);
-            control.id = V4L2_CID_BRIGHTNESS;
-            control.value = new_val;
-
-            ret = ioctl(dev->v4l2_fd, VIDIOC_S_CTRL, &control);
-            if (-1 == ret) {
-                printf("V4L2: VIDIOC_S_CTRL failed: %s (%d).\n", strerror(errno), errno);
-                return ret;
-            }
-        }
-        printf("V4L2: Brightness control changed to value = 0x%x\n", new_val);
-        break;
-
-    default:
-        /* TODO: We don't support any other controls. */
-        return -EINVAL;
-    }
-
-    return 0;
-}
-
-static int v4l2_start_capturing(struct v4l2_device *dev)
-{
-    int type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    int ret;
-
-    ret = ioctl(dev->v4l2_fd, VIDIOC_STREAMON, &type);
-    if (ret < 0) {
-        printf("V4L2: Unable to start streaming: %s (%d).\n", strerror(errno), errno);
-        return ret;
-    }
-
-    printf("V4L2: Starting video stream.\n");
-
-    return 0;
-}
-
-static int v4l2_stop_capturing(struct v4l2_device *dev)
-{
-    enum v4l2_buf_type type;
-    int ret;
-
-    switch (dev->io) {
-    case IO_METHOD_MMAP:
-        type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-
-        ret = ioctl(dev->v4l2_fd, VIDIOC_STREAMOFF, &type);
-        if (ret < 0) {
-            printf("V4L2: VIDIOC_STREAMOFF failed: %s (%d).\n", strerror(errno), errno);
-            return ret;
-        }
-
-        break;
-    default:
-        /* Nothing to do. */
-        break;
-    }
-
-    return 0;
-}
-static int v4l2_open(struct v4l2_device **v4l2, char *devname, struct v4l2_format *s_fmt)
-{
-    struct v4l2_device *dev;
-    struct v4l2_capability cap;
-    int fd;
-    int ret = -EINVAL;
-
-    fd = open(devname, O_RDWR | O_NONBLOCK, 0);
-    if (fd == -1) {
-        printf("V4L2: device open failed: %s (%d).\n", strerror(errno), errno);
-        return ret;
-    }
-
-    ret = ioctl(fd, VIDIOC_QUERYCAP, &cap);
-    if (ret < 0) {
-        printf("V4L2: VIDIOC_QUERYCAP failed: %s (%d).\n", strerror(errno), errno);
-        goto err;
-    }
-
-    if (!(cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)) {
-        printf("V4L2: %s is no video capture device\n", devname);
-        goto err;
-    }
-
-    if (!(cap.capabilities & V4L2_CAP_STREAMING)) {
-        printf("V4L2: %s does not support streaming i/o\n", devname);
-        goto err;
-    }
-
-    dev = calloc(1, sizeof *dev);
-    if (dev == NULL) {
-        ret = -ENOMEM;
-        goto err;
-    }
-
-    printf("V4L2 device is %s on bus %s\n", cap.card, cap.bus_info);
-
-    dev->v4l2_fd = fd;
-
-    /* Get the default image format supported. */
-    ret = v4l2_get_format(dev);
-    if (ret < 0)
-        goto err_free;
-
-    /*
-     * Set the desired image format.
-     * Note: VIDIOC_S_FMT may change width and height.
-     */
-    ret = v4l2_set_format(dev, s_fmt);
-    if (ret < 0)
-        goto err_free;
-
-    /* Get the changed image format. */
-    ret = v4l2_get_format(dev);
-    if (ret < 0)
-        goto err_free;
-
-    printf("v4l2 open succeeded, file descriptor = %d\n", fd);
-
-    *v4l2 = dev;
-
-    return 0;
-
-err_free:
-    free(dev);
-err:
-    close(fd);
-
-    return ret;
-}
-
-static void v4l2_close(struct v4l2_device *dev)
-{
-    close(dev->v4l2_fd);
-    free(dev);
-}
-
 /* ---------------------------------------------------------------------------
  * UVC generic stuff
  */
@@ -884,23 +391,53 @@ static void uvc_close(struct uvc_device *dev)
 static void uvc_video_fill_buffer(struct uvc_device *dev, struct v4l2_buffer *buf)
 {
     unsigned int bpl;
-    unsigned int i;
+    typeof(dev->shm_ptr) shm_ptr = dev->shm_ptr;
+    atomic_store(&shm_ptr->consumer_reading, 1);
+    uint8_t current_buffer = atomic_load(&shm_ptr->current_buffer);
+    uint8_t is_mjpeg = !!(current_buffer & 0x80);
+    current_buffer &= 0x0f;
+    unsigned char *img_data = shm_ptr->buffer[current_buffer];
+
+#ifdef ENABLE_BUFFER_DEBUG
+    printf("filling '%c%c%c%c' buffer [%u](%p)\n", pixfmtstr(dev->fcc), buf->index, dev->mem[buf->index].start);
+#endif
 
     switch (dev->fcc) {
     case V4L2_PIX_FMT_YUYV:
         /* Fill the buffer with video data. */
         bpl = dev->width * 2;
-        for (i = 0; i < dev->height; ++i)
-            memset(dev->mem[buf->index].start + i * bpl, dev->color++, bpl);
+        if (is_mjpeg){
+            const __u32 yuyv_map[] = {
+                v4l2_fourcc(0x00, 0x80, 0x00, 0x80), // black
+                v4l2_fourcc(0xFF, 0x80, 0xFF, 0x80), // white
+                v4l2_fourcc(0x4C, 0x55, 0x4C, 0xFF), // red
+                v4l2_fourcc(0x1D, 0xFF, 0x1D, 0x6B), // blue
+                v4l2_fourcc(0xE2, 0x00, 0xE2, 0x95), // yellow 
+                v4l2_fourcc(0xB3, 0xAB, 0xB3, 0x00), // cyan
+            };
+            __u32 yuyv_used = yuyv_map[(buf->index) % ARRAY_SIZE(yuyv_map)];
+            for (size_t i = 0; i < dev->height; ++i)
+                for (size_t j = 0; j < bpl/sizeof (__u32); ++j)
+                    ((__u32*)(dev->mem[buf->index].start + i*bpl))[j] = yuyv_used;
+        } else {
+            memcpy(dev->mem[buf->index].start, img_data, bpl * dev->height);
+        }
 
         buf->bytesused = bpl * dev->height;
         break;
 
     case V4L2_PIX_FMT_MJPEG:
-        memcpy(dev->mem[buf->index].start, dev->imgdata, dev->imgsize);
-        buf->bytesused = dev->imgsize;
+        if (!is_mjpeg) {
+            memcpy(dev->mem[buf->index].start, dev->imgdata, dev->imgsize);
+            buf->bytesused = dev->imgsize;
+        } else {
+            buf->bytesused = *(uint32_t*)img_data;
+            memcpy(dev->mem[buf->index].start, img_data+4, buf->bytesused);
+        }
+
         break;
     }
+    atomic_store(&shm_ptr->consumer_reading, 0);
 }
 
 static int uvc_video_process(struct uvc_device *dev)
@@ -949,75 +486,6 @@ static int uvc_video_process(struct uvc_device *dev)
 
 #ifdef ENABLE_BUFFER_DEBUG
         printf("ReQueueing buffer at UVC side = %d\n", ubuf.index);
-#endif
-    } else {
-        /* UVC - V4L2 integrated path. */
-
-        /*
-         * Return immediately if V4L2 video capture device has not
-         * started streaming yet or if QBUF was not called even once on
-         * the UVC side.
-         */
-        if (!dev->vdev->is_streaming || !dev->first_buffer_queued)
-            return 0;
-
-        /*
-         * Do not dequeue buffers from UVC side until there are atleast
-         * 2 buffers available at UVC domain.
-         */
-        if (!dev->uvc_shutdown_requested)
-            if ((dev->dqbuf_count + 1) >= dev->qbuf_count)
-                return 0;
-
-        /* Dequeue the spent buffer from UVC domain */
-        ret = ioctl(dev->uvc_fd, VIDIOC_DQBUF, &ubuf);
-        if (ret < 0) {
-            printf("UVC: Unable to dequeue buffer: %s (%d).\n", strerror(errno), errno);
-            return ret;
-        }
-
-        if (dev->io == IO_METHOD_USERPTR)
-            for (i = 0; i < dev->nbufs; ++i)
-                if (ubuf.m.userptr == (unsigned long)dev->vdev->mem[i].start && ubuf.length == dev->vdev->mem[i].length)
-                    break;
-
-        dev->dqbuf_count++;
-
-#ifdef ENABLE_BUFFER_DEBUG
-        printf("DeQueued buffer at UVC side=%d\n", ubuf.index);
-#endif
-
-        /*
-         * If the dequeued buffer was marked with state ERROR by the
-         * underlying UVC driver gadget, do not queue the same to V4l2
-         * and wait for a STREAMOFF event on UVC side corresponding to
-         * set_alt(0). So, now all buffers pending at UVC end will be
-         * dequeued one-by-one and we will enter a state where we once
-         * again wait for a set_alt(1) command from the USB host side.
-         */
-        if (ubuf.flags & V4L2_BUF_FLAG_ERROR) {
-            dev->uvc_shutdown_requested = 1;
-            printf(
-                "UVC: Possible USB shutdown requested from "
-                "Host, seen during VIDIOC_DQBUF\n");
-            return 0;
-        }
-
-        /* Queue the buffer to V4L2 domain */
-        CLEAR(vbuf);
-
-        vbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        vbuf.memory = V4L2_MEMORY_MMAP;
-        vbuf.index = ubuf.index;
-
-        ret = ioctl(dev->vdev->v4l2_fd, VIDIOC_QBUF, &vbuf);
-        if (ret < 0)
-            return ret;
-
-        dev->vdev->qbuf_count++;
-
-#ifdef ENABLE_BUFFER_DEBUG
-        printf("ReQueueing buffer at V4L2 side = %d\n", vbuf.index);
 #endif
     }
 
@@ -1069,6 +537,8 @@ static int uvc_video_qbuf_userptr(struct uvc_device *dev)
             buf.length = dev->dummy_buf[i].length;
             buf.index = i;
 
+            uvc_video_fill_buffer(dev, &(dev->mem[i].buf));
+
             ret = ioctl(dev->uvc_fd, VIDIOC_QBUF, &buf);
             if (ret < 0) {
                 printf("UVC: VIDIOC_QBUF failed : %s (%d).\n", strerror(errno), errno);
@@ -1225,7 +695,8 @@ static int uvc_video_reqbufs_userptr(struct uvc_device *dev, int nbufs)
             payload_size = dev->width * dev->height * 2;
             break;
         case V4L2_PIX_FMT_MJPEG:
-            payload_size = dev->imgsize;
+            // important
+            payload_size = dev->width * dev->height * 3 / 2;
             break;
         }
 
@@ -1237,13 +708,6 @@ static int uvc_video_reqbufs_userptr(struct uvc_device *dev, int nbufs)
                 ret = -ENOMEM;
                 goto err;
             }
-
-            if (V4L2_PIX_FMT_YUYV == dev->fcc)
-                for (j = 0; j < dev->height; ++j)
-                    memset(dev->dummy_buf[i].start + j * bpl, dev->color++, bpl);
-
-            if (V4L2_PIX_FMT_MJPEG == dev->fcc)
-                memcpy(dev->dummy_buf[i].start, dev->imgdata, dev->imgsize);
         }
 
         dev->mem = dev->dummy_buf;
@@ -1293,30 +757,6 @@ static int uvc_handle_streamon_event(struct uvc_device *dev)
     if (ret < 0)
         goto err;
 
-    if (!dev->run_standalone) {
-        /* UVC - V4L2 integrated path. */
-        if (IO_METHOD_USERPTR == dev->vdev->io) {
-            /*
-             * Ensure that the V4L2 video capture device has already
-             * some buffers queued.
-             */
-            ret = v4l2_reqbufs(dev->vdev, dev->vdev->nbufs);
-            if (ret < 0)
-                goto err;
-        }
-
-        ret = v4l2_qbuf(dev->vdev);
-        if (ret < 0)
-            goto err;
-
-        /* Start V4L2 capturing now. */
-        ret = v4l2_start_capturing(dev->vdev);
-        if (ret < 0)
-            goto err;
-
-        dev->vdev->is_streaming = 1;
-    }
-
     /* Common setup. */
 
     /* Queue buffers to UVC domain and start streaming. */
@@ -1374,7 +814,7 @@ uvc_fill_streaming_control(struct uvc_device *dev, struct uvc_streaming_control
         ctrl->dwMaxVideoFrameSize = frame->width * frame->height * 2;
         break;
     case V4L2_PIX_FMT_MJPEG:
-        ctrl->dwMaxVideoFrameSize = dev->imgsize;
+        ctrl->dwMaxVideoFrameSize = frame->width * frame->height * 3/2;
         break;
     }
 
@@ -1748,7 +1188,7 @@ uvc_events_process_control_data(struct uvc_device *dev, uint8_t cs, uint8_t enti
 {
     switch (entity_id) {
     /* Processing unit 'UVC_VC_PROCESSING_UNIT'. */
-    case 2:
+    case UVC_VC_PROCESSING_UNIT:
         switch (cs) {
         /*
          * We support only 'UVC_PU_BRIGHTNESS_CONTROL' for Processing
@@ -1757,7 +1197,7 @@ uvc_events_process_control_data(struct uvc_device *dev, uint8_t cs, uint8_t enti
         case UVC_PU_BRIGHTNESS_CONTROL:
             memcpy(&dev->brightness_val, data->data, data->length);
             /* UVC - V4L2 integrated path. */
-            if (!dev->run_standalone)
+            if (!dev->run_standalone) {
                 /*
                  * Try to change the Brightness attribute on
                  * Video capture device. Note that this try may
@@ -1776,7 +1216,9 @@ uvc_events_process_control_data(struct uvc_device *dev, uint8_t cs, uint8_t enti
                  * compliant, we should return the same value
                  * accordingly.
                  */
-                v4l2_set_ctrl(dev->vdev, dev->brightness_val, V4L2_CID_BRIGHTNESS);
+                // v4l2_set_ctrl(dev->vdev, dev->brightness_val, V4L2_CID_BRIGHTNESS);
+            }
+            printf("UVC: Setting brightness to: %u\n", dev->brightness_val);
             break;
 
         default:
@@ -1798,7 +1240,7 @@ static int uvc_events_process_data(struct uvc_device *dev, struct uvc_request_da
 {
     struct uvc_streaming_control *target;
     struct uvc_streaming_control *ctrl;
-    struct v4l2_format fmt;
+    // struct v4l2_format fmt;
     const struct uvc_format_info *format;
     const struct uvc_frame_info *frame;
     const unsigned int *interval;
@@ -1832,7 +1274,7 @@ static int uvc_events_process_data(struct uvc_device *dev, struct uvc_request_da
         if (*val > PU_BRIGHTNESS_MAX_VAL) {
             return -EINVAL;
         } else {
-            ret = uvc_events_process_control_data(dev, UVC_PU_BRIGHTNESS_CONTROL, 2, data);
+            ret = uvc_events_process_control_data(dev, UVC_PU_BRIGHTNESS_CONTROL, UVC_VC_PROCESSING_UNIT, data);
             if (ret < 0)
                 goto err;
 
@@ -1864,7 +1306,7 @@ static int uvc_events_process_data(struct uvc_device *dev, struct uvc_request_da
     case V4L2_PIX_FMT_MJPEG:
         if (dev->imgsize == 0)
             printf("WARNING: MJPEG requested and no image loaded.\n");
-        target->dwMaxVideoFrameSize = dev->imgsize;
+        target->dwMaxVideoFrameSize = frame->width * frame->height * 3/2;
         break;
     }
     target->dwFrameInterval = *interval;
@@ -1873,6 +1315,8 @@ static int uvc_events_process_data(struct uvc_device *dev, struct uvc_request_da
         dev->fcc = format->fcc;
         dev->width = frame->width;
         dev->height = frame->height;
+
+		// uvc_video_set_format(dev);
     }
 
     return 0;
@@ -1924,13 +1368,6 @@ static void uvc_events_process(struct uvc_device *dev)
         return;
 
     case UVC_EVENT_STREAMOFF:
-        /* Stop V4L2 streaming... */
-        if (!dev->run_standalone && dev->vdev->is_streaming) {
-            /* UVC - V4L2 integrated path. */
-            v4l2_stop_capturing(dev->vdev);
-            dev->vdev->is_streaming = 0;
-        }
-
         /* ... and now UVC streaming.. */
         if (dev->is_streaming) {
             uvc_video_stream(dev, 0);
@@ -1960,7 +1397,7 @@ static void uvc_events_init(struct uvc_device *dev)
         payload_size = dev->width * dev->height * 2;
         break;
     case V4L2_PIX_FMT_MJPEG:
-        payload_size = dev->imgsize;
+        payload_size = dev->width * dev->height * 3/2;
         break;
     }
 
@@ -2002,7 +1439,7 @@ static void image_load(struct uvc_device *dev, const char *img)
 
     dev->imgsize = lseek(fd, 0, SEEK_END);
     lseek(fd, 0, SEEK_SET);
-    dev->imgdata = malloc(dev->imgsize);
+    dev->imgdata = malloc(dev->width * dev->height * 3/2);
     if (dev->imgdata == NULL) {
         printf("Unable to allocate memory for MJPEG image\n");
         dev->imgsize = 0;
@@ -2011,6 +1448,7 @@ static void image_load(struct uvc_device *dev, const char *img)
 
     read(fd, dev->imgdata, dev->imgsize);
     close(fd);
+    printf("Load MJPEG image '%s' %u bytes @ %p\n", img, dev->imgsize, dev->imgdata);
 }
 
 static void usage(const char *argv0)
@@ -2048,14 +1486,12 @@ static void usage(const char *argv0)
 int main(int argc, char *argv[])
 {
     struct uvc_device *udev;
-    struct v4l2_device *vdev;
     struct timeval tv;
     struct v4l2_format fmt;
     char *uvc_devname = "/dev/video0";
-    char *v4l2_devname = "/dev/video1";
     char *mjpeg_image = NULL;
 
-    fd_set fdsv, fdsu;
+    fd_set fdsu;
     int ret, opt, nfds;
     int bulk_mode = 0;
     int dummy_data_gen_mode = 0;
@@ -2069,7 +1505,7 @@ int main(int argc, char *argv[])
     enum usb_device_speed speed = USB_SPEED_SUPER; /* High-Speed */
     enum io_method uvc_io_method = IO_METHOD_USERPTR;
 
-    while ((opt = getopt(argc, argv, "bdf:hi:m:n:o:r:s:t:u:v:")) != -1) {
+    while ((opt = getopt(argc, argv, "bdf:hi:m:n:o:r:s:t:u:")) != -1) {
         switch (opt) {
         case 'b':
             bulk_mode = 1;
@@ -2158,10 +1594,6 @@ int main(int argc, char *argv[])
             uvc_devname = optarg;
             break;
 
-        case 'v':
-            v4l2_devname = optarg;
-            break;
-
         default:
             printf("Invalid option '-%c'\n", opt);
             usage(argv[0]);
@@ -2169,40 +1601,169 @@ int main(int argc, char *argv[])
         }
     }
 
-    if (!dummy_data_gen_mode && !mjpeg_image) {
-        /*
-         * Try to set the default format at the V4L2 video capture
-         * device as requested by the user.
-         */
-        CLEAR(fmt);
-        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        fmt.fmt.pix.width = (default_resolution == 0) ? 640 : 1280;
-        fmt.fmt.pix.height = (default_resolution == 0) ? 360 : 720;
-        fmt.fmt.pix.sizeimage = (default_format == 0) ? (fmt.fmt.pix.width * fmt.fmt.pix.height * 2)
-                                                      : (fmt.fmt.pix.width * fmt.fmt.pix.height * 1.5);
-        fmt.fmt.pix.pixelformat = (default_format == 0) ? V4L2_PIX_FMT_YUYV : V4L2_PIX_FMT_MJPEG;
-        fmt.fmt.pix.field = V4L2_FIELD_ANY;
-
-        /* Open the V4L2 device. */
-        ret = v4l2_open(&vdev, v4l2_devname, &fmt);
-        if (vdev == NULL || ret < 0)
-            return 1;
-    }
-
     /* Open the UVC device. */
     ret = uvc_open(&udev, uvc_devname);
     if (udev == NULL || ret < 0)
         return 1;
 
-    udev->uvc_devname = uvc_devname;
 
-    if (!dummy_data_gen_mode && !mjpeg_image) {
-        vdev->v4l2_devname = v4l2_devname;
-        /* Bind UVC and V4L2 devices. */
-        udev->vdev = vdev;
-        vdev->udev = udev;
+
+    // fill uvc_formats
+    {
+        // echo /sys/kernel/config/usb_gadget/g0/functions/uvc.usb0/streaming/uncompressed/u/*p
+        // echo /sys/kernel/config/usb_gadget/g0/functions/uvc.usb0/streaming/mjpeg/m/*p
+        // /sys/kernel/config/usb_gadget/*/functions/uvc*/streaming/mjpeg/m/360p/bFrameIndex dwFrameInterval wWidth wHeight
+        // FRAMES_SUPPORT_MAX
+        char uvc_streaming_path[128];
+        {
+            FILE *fp = popen("realpath /sys/kernel/config/usb_gadget/*/functions/uvc*/streaming", "r");
+            if (!fp) {
+                perror("popen failed");
+                return 1;
+            }
+            if (!fgets(uvc_streaming_path, sizeof(uvc_streaming_path), fp)) {
+                pclose(fp);
+                perror("find uvc_streaming_path failed");
+                return 1;
+            }
+            pclose(fp);
+            uvc_streaming_path[strcspn(uvc_streaming_path, "\n")] = '\0';
+        }
+        // get /sys/kernel/config/usb_gadget/g0/functions/uvc.usb0/streaming in `uvc_streaming_path`
+
+        {
+            int ret;
+            glob_t glob_result;
+            char *combined_path;
+            const char *frames_pattern[2] = {
+                "uncompressed/u/*p",
+                "mjpeg/m/*p",
+            };
+
+            for (size_t frame_type=0; frame_type<ARRAY_SIZE(frames_pattern); frame_type++) {
+                ret = asprintf(&combined_path, "%s/%s", uvc_streaming_path, frames_pattern[frame_type]);
+                if (ret == -1) {
+                    fprintf(stderr, "asprintf %s failed\n", combined_path);
+                    return 1;
+                }
+                ret = glob(combined_path, GLOB_TILDE, NULL, &glob_result);
+                free(combined_path);
+                if (ret) {
+                    fprintf(stderr, "glob %s failed\n", combined_path);
+                    return 1;
+                }
+
+                size_t frame_count = 0;
+                for (size_t i = 0; i < glob_result.gl_pathc; i++) {
+                    // printf("  %s\n", glob_result.gl_pathv[i]);
+                    unsigned int bFrameIndex;
+                    ret = asprintf(&combined_path, "%s/%s", glob_result.gl_pathv[i], "bFrameIndex");
+                    if (ret == -1) {
+                        fprintf(stderr, "asprintf %s failed\n", combined_path);
+                        return 1;
+                    }
+                    ret = read_fs_values(combined_path, "%u", &bFrameIndex, 1);
+                    if (ret != 1) {
+                        fprintf(stderr, "read_fs_values %s failed\n", combined_path);
+                        return 1;
+                    }
+                    free(combined_path);
+                    if (bFrameIndex > FRAMES_SUPPORT_MAX) continue;
+                    frame_count += 1;
+
+                    // dwFrameInterval wWidth wHeight
+                    ret = asprintf(&combined_path, "%s/%s", glob_result.gl_pathv[i], "wWidth");
+                    if (ret == -1) {
+                        fprintf(stderr, "asprintf %s failed\n", combined_path);
+                        return 1;
+                    }
+                    ret = read_fs_values(combined_path, "%u", &uvc_formats[frame_type].frames[bFrameIndex-1].width, 1);
+                    if (ret != 1) {
+                        fprintf(stderr, "read_fs_values %s failed\n", combined_path);
+                        return 1;
+                    }
+                    free(combined_path);
+
+                    ret = asprintf(&combined_path, "%s/%s", glob_result.gl_pathv[i], "wHeight");
+                    if (ret == -1) {
+                        fprintf(stderr, "asprintf %s failed\n", combined_path);
+                        return 1;
+                    }
+                    ret = read_fs_values(combined_path, "%u", &uvc_formats[frame_type].frames[bFrameIndex-1].height, 1);
+                    if (ret != 1) {
+                        fprintf(stderr, "read_fs_values %s failed\n", combined_path);
+                        return 1;
+                    }
+                    free(combined_path);
+
+                    ret = asprintf(&combined_path, "%s/%s", glob_result.gl_pathv[i], "dwFrameInterval");
+                    if (ret == -1) {
+                        fprintf(stderr, "asprintf %s failed\n", combined_path);
+                        return 1;
+                    }
+                    ret = read_fs_values(combined_path, "%u", &uvc_formats[frame_type].frames[bFrameIndex-1].intervals[0], 7);
+                    if (ret <= 0) {
+                        fprintf(stderr, "read_fs_values %s failed\n", combined_path);
+                        return 1;
+                    }
+                    free(combined_path);
+                    // fill the end of `intervals`
+                    uvc_formats[frame_type].frames[bFrameIndex-1].intervals[ret] = 0;
+                }
+                globfree(&glob_result);
+                // fill the end of `frames`
+                uvc_formats[frame_type].frames[frame_count].width = 0;
+                uvc_formats[frame_type].frames[frame_count].height = 0;
+                uvc_formats[frame_type].frames[frame_count].intervals[0] = 0;
+                
+            }
+
+            // default
+            // 1 /sys/kernel/config/usb_gadget/*/functions/uvc*/streaming/uncompressed/u/bFormatIndex
+            // 2 /sys/kernel/config/usb_gadget/*/functions/uvc*/streaming/mjpeg/m/bFormatIndex
+            // sys/kernel/config/usb_gadget/g0/functions/uvc.usb0/streaming/uncompressed/u/bFormatIndex
+            unsigned int yuyv_format_index;
+            if (asprintf(&combined_path, "%s/%s", uvc_streaming_path, "uncompressed/u/bFormatIndex") == -1) {
+                fprintf(stderr, "asprintf %s failed\n", combined_path);
+                return 1;
+            }
+            ret = read_fs_values(combined_path, "%u", &yuyv_format_index, 1);
+            if (ret != 1) {
+                fprintf(stderr, "read_fs_values %s failed\n", combined_path);
+                return 1;
+            }
+            free(combined_path);
+            if (yuyv_format_index == 2) {
+                uvc_formats[0].fcc = V4L2_PIX_FMT_MJPEG;
+                uvc_formats[0].frames = uvc_frames_mjpeg;
+                uvc_formats[1].fcc = V4L2_PIX_FMT_YUYV;
+                uvc_formats[1].frames = uvc_frames_yuyv;
+            }
+        }
+
+        {
+            // log
+            const struct uvc_format_info *format;
+            const struct uvc_frame_info *frame;
+
+            for (size_t iformat=0; iformat<ARRAY_SIZE(uvc_formats); iformat++) {
+                format = &uvc_formats[iformat];
+                unsigned int nframes = 0;
+                while (format->frames[nframes].width != 0)
+                    ++nframes;
+                printf("Format %c%c%c%c (%u):\n", pixfmtstr(format->fcc), nframes);
+
+                for (size_t iframe=0; iframe<nframes; iframe++) {
+                    frame = &format->frames[iframe];
+                    printf("[%zu]=\t%ux%u\n", iframe, frame->width, frame->height);
+                }
+                puts("");
+            }
+        }
     }
 
+    udev->uvc_devname = uvc_devname;
+
     /* Set parameters as passed by user. */
     udev->width = (default_resolution == 0) ? 640 : 1280;
     udev->height = (default_resolution == 0) ? 360 : 720;
@@ -2219,27 +1780,7 @@ int main(int argc, char *argv[])
         /* UVC standalone setup. */
         udev->run_standalone = 1;
 
-    if (!dummy_data_gen_mode && !mjpeg_image) {
-        /* UVC - V4L2 integrated path */
-        vdev->nbufs = nbufs;
-
-        /*
-         * IO methods used at UVC and V4L2 domains must be
-         * complementary to avoid any memcpy from the CPU.
-         */
-        switch (uvc_io_method) {
-        case IO_METHOD_MMAP:
-            vdev->io = IO_METHOD_USERPTR;
-            break;
-
-        case IO_METHOD_USERPTR:
-        default:
-            vdev->io = IO_METHOD_MMAP;
-            break;
-        }
-    }
-
-    switch (speed) {
+    switch (udev->speed) {
     case USB_SPEED_FULL:
         /* Full Speed. */
         if (bulk_mode)
@@ -2266,24 +1807,43 @@ int main(int argc, char *argv[])
         break;
     }
 
-    if (!dummy_data_gen_mode && !mjpeg_image && (IO_METHOD_MMAP == vdev->io)) {
-        /*
-         * Ensure that the V4L2 video capture device has already some
-         * buffers queued.
-         */
-        v4l2_reqbufs(vdev, vdev->nbufs);
+    if (mjpeg_image) {
+        image_load(udev, mjpeg_image);
     }
 
-    if (mjpeg_image)
-        image_load(udev, mjpeg_image);
+    udev->shm_fd = -1;
+    udev->shm_ptr = NULL;
+    if (udev->run_standalone) {
+        // 1. 打开共享内存
+        int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
+        if (shm_fd == -1) {
+            perror("shm_open failed");
+            exit(EXIT_FAILURE);
+        }
+        printf("shm_open: %s succeed\n", SHM_NAME);
+
+        udev->shm_fd = shm_fd;
+
+        // 配置共享内存大小
+        if (ftruncate(shm_fd, SHM_SIZE) == -1) {
+            perror("ftruncate failed");
+            exit(EXIT_FAILURE);
+        }
+
+        // 2. 将共享内存映射到进程的地址空间
+        void *shared_mem = mmap(NULL, SHM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
+        if (shared_mem == MAP_FAILED) {
+            perror("mmap failed");
+            exit(EXIT_FAILURE);
+        }
+
+        udev->shm_ptr = (shared_mem_t *)shared_mem;
+    }
 
     /* Init UVC events. */
     uvc_events_init(udev);
 
     while (1) {
-        if (!dummy_data_gen_mode && !mjpeg_image)
-            FD_ZERO(&fdsv);
-
         FD_ZERO(&fdsu);
 
         /* We want both setup and data events on UVC interface.. */
@@ -2292,49 +1852,28 @@ int main(int argc, char *argv[])
         fd_set efds = fdsu;
         fd_set dfds = fdsu;
 
-        /* ..but only data events on V4L2 interface */
-        if (!dummy_data_gen_mode && !mjpeg_image)
-            FD_SET(vdev->v4l2_fd, &fdsv);
-
         /* Timeout. */
-        tv.tv_sec = 2;
+        tv.tv_sec = 5;
         tv.tv_usec = 0;
-
-        if (!dummy_data_gen_mode && !mjpeg_image) {
-            nfds = max(vdev->v4l2_fd, udev->uvc_fd);
-            ret = select(nfds + 1, &fdsv, &dfds, &efds, &tv);
-        } else {
-            ret = select(udev->uvc_fd + 1, NULL, &dfds, &efds, NULL);
-        }
+        ret = select(udev->uvc_fd + 1, NULL, udev->is_streaming ? &dfds : NULL, &efds, &tv);
 
         if (-1 == ret) {
             printf("select error %d, %s\n", errno, strerror(errno));
             if (EINTR == errno)
                 continue;
 
-            break;
+            continue;
         }
 
         if (0 == ret) {
             printf("select timeout\n");
-            break;
+            continue;
         }
 
         if (FD_ISSET(udev->uvc_fd, &efds))
             uvc_events_process(udev);
         if (FD_ISSET(udev->uvc_fd, &dfds))
             uvc_video_process(udev);
-        if (!dummy_data_gen_mode && !mjpeg_image)
-            if (FD_ISSET(vdev->v4l2_fd, &fdsv))
-                v4l2_process_data(vdev);
-    }
-
-    if (!dummy_data_gen_mode && !mjpeg_image && vdev->is_streaming) {
-        /* Stop V4L2 streaming... */
-        v4l2_stop_capturing(vdev);
-        v4l2_uninit_device(vdev);
-        v4l2_reqbufs(vdev, 0);
-        vdev->is_streaming = 0;
     }
 
     if (udev->is_streaming) {
@@ -2345,8 +1884,11 @@ int main(int argc, char *argv[])
         udev->is_streaming = 0;
     }
 
-    if (!dummy_data_gen_mode && !mjpeg_image)
-        v4l2_close(vdev);
+    // 5. 释放资源
+    if (udev->shm_ptr)
+        munmap(udev->shm_ptr, SHM_SIZE);
+    if (udev->shm_fd != -1)
+        close(udev->shm_fd);
 
     uvc_close(udev);
     return 0;
-- 
2.34.1

